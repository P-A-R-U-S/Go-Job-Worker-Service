---
authors: Valentyn Ponomarenko (ValentynPonomarenko@gmail.com)
state: draft
---

# RFD 00001 - Job Worker Service

## Required Approvers

Engineering: [@smallinsky](https://github.com/smallinsky) || [@greedy52](https://github.com/greedy52) || [@r0mant](https://github.com/r0mant)  || [@russjones](https://github.com/russjones)


## What

Design job worker service (JobWorker) that enables authorized users run arbitrary
Linux command on remote hosts via cli.

## Why
This library can be used to execute arbitrary linux commands on a machine and provide basic 
resource control for the process using [cgroups](https://en.wikipedia.org/wiki/Cgroups). 

The main purpose of this to test candidate skills and ability to create productions code and API, 
and let candidate know what it would be like to work at [Teleport](https://goteleport.com/). 
But in general tool can be used to run a variety of Linux processes on a remote machine:
- short-lived command - e.g. _$(which date)_
- long-lived command  - e.g. _bash -c 'for ((i=0; i<100;++i)); do echo index:$i; sleep 1; done'_

Because each job process is isolated for security purposes and limited resources consumption - 
such service can be considered as lightweight alternative of Docker containers.

## Details
The project should be composed of three components:

* **Library** - reusable Go library that provide base functionality to start/stop
  and query status of the job, as well as able to stream the output generated by the job.
  The library support multiple concurrent clients simultaneously and the job output
  availability limited by client permission. Each job assigned to it own CPU,
  Memory and DiskIO groups to limit process' resource consumptions.


* **API** - [gRPC](https://grpc.io/) API server side application that enables mTLS client authentication
  and verify client certificates. API handle and report clear errors and not crash under non-critical
  conditions.

  Set up strong set of cipher suites for TLS and good crypto setup for certificates.

  No any other authentication protocols should be used on top of mTLS.


* **Client** - the client is command line interface (cli) to connect to the API
  and provide same set of operations (start/stop/query status/stream output of the job)

>_Note: the team proposed [Golang](https://go.dev/) language as preferable_

#### Assumptions
* no user hierarchy and all user are isolated _(all user equal and not able to start/stop/query command from other users)_
* due to limit of time and scope we should support cgroups v2 and cgroups should be setup on the machine
* machine has enough memory to run all the jobs and store jobs' output in memory 
* service run using preconfigures IP ADDRESS:PORT 
* no any data should be persisted _(include configuration, mTLS certificates, jobs output and etc)_

#### Not supported (Out of scope)
* high availability _(single instance run on single Linux 64-bit machine)_
* no cgroup configuration such as PID limits, memory.

### Library
Independent public library (package) support running arbitrary Linux 64-bit process in isolation 
with resource limits. Package not have any dependency on external packages and know nothing 
about API and Client/CLI. 

All jobs should be safe for concurrent use and every process should be isolated and run in separate 
goroutine. Library can use concurrency primitives _(mutex, channels, wait groups)_ to handle concurrent 
changes of the job's state such as stop being invoked multiple times concurrently and write jobs output. 

Every job has the following attributes: 
* _`PID namespace`_ - to prevent a process from killing other processes running on the machine not created by the job
* _`Network namespace`_ - to prevent all receiving or sending network traffic both on the local network and internet
* _`Mount namespace`_  - to prevents modifying the host's mounts

#### Resource limitation
The process's resources are limited by configuring cgroups. 
The user is expected to provide CPU, memory, and IO limits.

#### Following primitives and functions considered to be used in library package.

* **type Job** - holds internal information about job.
  ```go
  type Job struct {
    UUID uuid.UUID
    Status *JobStatus
  }
  ```
  
* **type JobStatus** - holds information about current state of the job.
     ```go
    type JobStatus struct {
      State     string
      ExitCode  int
      ExitReason string
    }
    ```
  - _`State`_ latest state of the job (_Started, Executing, Stopped, Completed_).
  
  - _`ExitCode`_ - exit code (if process invoked exit), otherwise would be -1 if not in a completed state.
  
  - _`ExitReason`_ - error message returned by [exec.Cmd.Run](https://pkg.go.dev/os/exec#Cmd.Run) (if the process failed to run).


* **type JobConfig** - holds configuration for creating a new job.

  ```go
  type JobConfig struct {
    CPU              float64
    MemBytes         int64
    IOBytesPerSecond int64
    Command          string
    Arguments        []string
  }
  ```
  - _`CPU`_ - representing an approximate number of CPU cores to limit the job. 
  For example, 0.5 would translate to half a CPU core. This is configured by setting [cpu.max](https://docs.kernel.org/admin-guide/cgroup-v2.html)=500000 of 1000000 total. 
  
  - _`MemBytes`_ - maximum amount of memory used by the job. 
  This is configured by setting [memory.max](https://docs.kernel.org/admin-guide/cgroup-v2.html). 
  
  - _`IOBytesPerSecond`_ is the maximum read and write on the device mounted / is mounted on. 
  This is configured by setting [io.max](https://docs.kernel.org/admin-guide/cgroup-v2.html) in the cgroup for the process. 
  For example, a IOBytesPerSecond of 1000000000 would be similar to 259:1 rbps=1000000000 wbps=1000000000 riops=max wiops=max in the cgroup's io.max file. 

  - _`Command`_ is the command to execute. For example, _/bin/bash_. 
  
  - _`Arguments`_ are the arguments to pass to the command. 
  For example, "-c", "echo hello"}would be provided to command and ultimately run similar to /bin/bash -c "echo hello".


* **func New(config JobConfig) \*Job** - create new Job instance, based on provided job configuration.


* **func (\*Job) Start() error** - start job executions and return [error](https://pkg.go.dev/errors) if job failed to start or required fields contains no value.

  Starting new job tart takes following steps:

  - create new [cgroup](https://docs.kernel.org/admin-guide/cgroup-v2.html) for the job - e.g `/sys/fs/cgroup/<UUID>`
  - create subtree to control resources - e.g. `+cpu +memory +io` into file `/sys/fs/cgroup/<UUID>/cgroup.subtree_control`
  - set value for CPU, Memory and IO limits based on job configuration 
    - `CPU` - set by writing QUOTA/PERIOD into `/sys/fs/cgroup/<UUID>/tasks/cpu.max`
    - `Memory` - set by writing the provided IOBytesPerSecond to `/sys/fs/cgroup/<uuid>/tasks/memory.max`
    - `IO` - is set by writing IOBytesPerSecond into `<MAJOR NUMBER OF PHYSICAL DEVICE>:<MINOR NUMBER OF PHYSICAL DEVICE> rbps=<IOBytesPerSecond> wbps=<IOBytesPerSecond> riops=max wiops=max` to `/sys/fs/cgroup/<UUID>/tasks/io.max` <br/><br/> _Note_:  `<MAJOR NUMBER OF PHYSICAL DEVICE>` and `<MINOR NUMBER OF PHYSICAL DEVICE>` shoudl be dynamically detected and provided during runtime.
  - configures a new [exec.Cmd](https://pkg.go.dev/os/exec#Cmd)
    - sets clone flags for creating new mount, pid, and network namespaces 
    - sets [unshare flags](https://pkg.go.dev/syscall#SysProcAttr) for mount so that new mounts are not reflected in host mount namespace 
    - sets [UseCgroupFD and CgroupFD](https://pkg.go.dev/syscall#SysProcAttr) to the cgroup's file descriptor such as `/sys/fs/cgroup/<UUID>/tasks`
  - runs the configured `exec.Cmd` in a new goroutine
    - does not wait for the command to complete 
    - the goroutine will stop when the process completes or is killed


* **func (\*Job) Status() JobStatus** - returns the current status of the job (see [JobStatus](#type-JobStatus))


* **func (\*Job) Stream() OutputReader** - returns an `OutputReader` (type that implements [io.Reader](https://pkg.go.dev/io#Reader)). 
`OutputReader` return entire output from when job started to the current output. `Stream` can call when job started, executing or completed.
Calling `Stream` for not-existing or not-started job returns empty `OutputReader`.


* **func (\*Job) Stop() error** - attempt to gracefully shutdown the process.
`Stop` will do nothing if the process has already completed or been killed.

### API 
The API is nothing more than just a wrapper around Library, but main API responsibility provide mTLS Authorization and using Library
functionality via [gRPC](https://grpc.io/)

#### Following functions considered to be used for API Server.

* `Start` New Job
  * verify user credentials via mTLS Authorization
  * create new instance of the `Job` and assign new UUID 
  * store `job` in sync.Map using UUID as key
  * start command execution
  * return UUID to the client
* `Status` of the Job
  * return current status of the `Job`
* `Stream` latest Job output
  * lookup `Job` by provided UUID
  * request instance of `OutputReader` using library
  * send steam output to the client/cli
* `Stop` Job
  * lookup `Job` by provided UUID
  * call `Stop` function if `Job` was found, otherwise return error
  
  > **Not any job and it output removed from then server**. So, depend on the load and size of total output it would come to OOM situation sooner or later and [panic](https://go.dev/blog/defer-panic-and-recover).
  > Probably we need to consider some API or process to clean completed jobs based on size, date of creation, frequency of usage or etc.
  

#### Security

The client and API communicate via mTLS using [TLS 1.3 ](https://datatracker.ietf.org/doc/html/rfc8446) as the minimum version. The following cipher suites are supported:

* TLS_AES_256_GCM_SHA384
* TLS_CHACHA20_POLY1305_SHA256
* TLS_AES_128_GCM_SHA256

> Note: only 3 cipher suites enabled openssl by default: https://wiki.openssl.org/index.php/TLS1.3, and following 2 
> below also can be used, but need to explicitly enabled: 
>* TLS_AES_128_CCM_8_SHA256
>* TLS_AES_128_CCM_SHA256

> Since there are no requirements for older versions of TLS to be supported, TLS v1.3 will be made a minimum.

#### Authorization
All verification should be done on API level and API treats the client's common name (CN) in the certificate as the user's identity.
Client not able interact with a job not created by them in any way (Stream, query Status, Stop for another user's job is not allowed).

API not cache any user authorization data and such data should be provided for every API call.

#### Proposed Protobuf
Following [protobuf](https://protobuf.dev/programming-guides/proto3/) proposed for the client/server:

```protobuf
  syntax = "proto3";

  package jobworker;
  
  // option go_package
  
  service JobWorker {
    rpc Start(JobConfig) returns (Job) {}
    rpc Status(Job) returns (JobStatus) {}
    rpc Stream(Job) returns (stream Output) {}
    rpc Stop(Job) returns (JobStatus) {}
  }
  
  message Job {
    string uuid = 1;
  }
  
  message JobConfig {
    double cpu = 1;
    int64 membytes = 2;
    int64 iobytespersecond = 3;
    string command = 4;
    repeated string args = 5;
  }
  
  message JobStatus {
    string status = 1;
    int32 exitcode = 2;
    string exitreason = 3;
  }
  
  message Output {
    bytes content = 1;
  }
```

### Client/CLI 

User interact with API via [CLI (A command-line interface)](https://en.wikipedia.org/wiki/Command-line_interface). 
Here is example below how user interact via CLI and expected output

> _Following command line package: https://github.com/urfave/cli considered as option for CLI implementation._

#### Starting new job

```text
    jw start --ca-cert <PATH_TO_CA_CERT> \
    --client-cert <PATH_TO_CLIENT_CERT> \
    --client-key <PATH_TO_CLIENT_KEY> \
    --cpu 0.5
    --memory 500000
    --io 1000000
    --c $(which date)
```

expected output

```text
Jod:<UUID> stared. 
```

> _Note: cpu, memory and io settings are not guarantee that system would allocate exactly same CPU time and memory.
> Based on system load process can have more or less of these settings._

#### Query job status

```text
  jw status --ca-cert <PATH_TO_CA_CERT> \
    --client-cert <PATH_TO_CLIENT_CERT> \
    --client-key <PATH_TO_CLIENT_KEY> \
    --id <UUID>
```

expected output if started
```text
Jod:<UUID> has status: Started. ExitCode:-1, ExitReason:
```

expected output if completed
```text
Jod:<UUID> has status: Completed. ExitCode:0, ExitReason:
```

expected output if failed to run
```text
Jod:<UUID> has status: Stopped. ExitCode:-1, ExitReason: <ERROR DETAILS>
```

#### Streaming job output
```text
  jw stream --ca-cert <PATH_TO_CA_CERT> \
    --client-cert <PATH_TO_CLIENT_CERT> \
    --client-key <PATH_TO_CLIENT_KEY> \
    --id <UUID>
```

expected output if completed
```text
Sat Aug 24 12:43:23 PDT 2024
```

The command will continue to print the output until the job completes or stopped.

In the case that the job has completed, the command will print the output and then exit.

#### Stopping a job

```text
  jw stop --ca-cert <PATH_TO_CA_CERT> \
    --client-cert <PATH_TO_CLIENT_CERT> \
    --client-key <PATH_TO_CLIENT_KEY> \
    --id <UUID>
```

expected output if completed
```text
Jod:<UUID> has status: Stopped. ExitCode:0, ExitReason:
```

### Test Plan
Create a few end-to-end tests to verify some behaviors like:

#### Positive use cases  
1. `Use Case #1:` Starting simple job, check job status and let the job complete.
2. `Use Case #2:` Starting simple job, Stop job, check job status is Stopped.
3. `Use Case #3:` Start long-running job, check status, stream job output, waiting for completions, check job status.
4. `Use Case #4:` Start Job for with User1, check job status, try to request status/stop job from User2. Expected behavior User2 should receive error. Stop job with User1 credentials.
5. `Use Case #5:` Start Job with limits for cpu - e.g. `sha1sum /dev/random` and to verify cpu.limit run second job `ps -p $(pgrep sha1sum) -o %cpu)` to verify CPU usage
6. `Use Case #6:` Start Job with limits for IO - e.g. `dd if=/dev/zero of=/tmp/test bs=512M count=1` to verify io.max ([dd](https://en.wikipedia.org/wiki/Dd_(Unix)) outputs rough approximations of read and write speeds)

#### Negative use cases 
1. `Use Case #1:` Try to `Stop`, `Status`, `Stream` non-exiting job.
2. `Use Case #2:` Try to `Start` jon with incorrect/broken certificate
3. `Use Case #3:` Call cli commands if server stopped/misconfigured. Expected behavior: should received message that server API is unreachable.